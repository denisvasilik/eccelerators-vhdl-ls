/*
 * generated by Xtext 2.14.0
 */
package com.eccelerators.plugins.vhdl.validation

import com.eccelerators.plugins.vhdl.vhdl.ArchitectureDeclaration
import com.eccelerators.plugins.vhdl.vhdl.ComponentDeclaration
import com.eccelerators.plugins.vhdl.vhdl.ComponentInstantiationStatement
import com.eccelerators.plugins.vhdl.vhdl.ConditionalSignalAssignmentSatement
import com.eccelerators.plugins.vhdl.vhdl.EntityDeclaration
import com.eccelerators.plugins.vhdl.vhdl.GenericClause
import com.eccelerators.plugins.vhdl.vhdl.Identifier
import com.eccelerators.plugins.vhdl.vhdl.IdentifierReference
import com.eccelerators.plugins.vhdl.vhdl.InterfaceDeclaration
import com.eccelerators.plugins.vhdl.vhdl.Model
import com.eccelerators.plugins.vhdl.vhdl.PortClause
import com.eccelerators.plugins.vhdl.vhdl.ProcedureDeclaration
import com.eccelerators.plugins.vhdl.vhdl.ProcedureSpecification
import com.eccelerators.plugins.vhdl.vhdl.ProcessStatement
import com.eccelerators.plugins.vhdl.vhdl.QualifiedIdentifierReference
import com.eccelerators.plugins.vhdl.vhdl.SignalAssignmentStatement
import com.eccelerators.plugins.vhdl.vhdl.SignalDeclaration
import com.google.common.collect.HashMultimap
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class VhdlValidator extends AbstractVhdlValidator {

	public static val INVALID_NAME = 'invalidName'

	@Check
	def checkForMultipleSignalDeclaration(InterfaceDeclaration interfaceDeclaration) {
		if(interfaceDeclaration.eContainer().eContainer() instanceof GenericClause ||
		   interfaceDeclaration.eContainer().eContainer() instanceof ProcedureSpecification ||
		   interfaceDeclaration.eContainer().eContainer() instanceof ProcedureDeclaration ) {
		   	return;
		}

		if(interfaceDeclaration.eContainer().eContainer().eContainer() instanceof EntityDeclaration) {
			val model = interfaceDeclaration.eResource().getContents().get(0) as Model;
			val entity = interfaceDeclaration.eContainer().eContainer().eContainer();
			val architectureDeclarations = EcoreUtil2.getAllContentsOfType(model, typeof(ArchitectureDeclaration));
			
			architectureDeclarations
				.filter[architecture| architecture.entityRef == entity]			
				.forEach[architecture|
				if(architecture === null) {
					return;
				}
				
				val interfaceDeclarations = EcoreUtil2.getAllContentsOfType(entity, typeof(InterfaceDeclaration));
				val signalDeclarations = EcoreUtil2.getAllContentsOfType(architecture, typeof(SignalDeclaration));
				
				val thisIdentifiers = new ArrayList<Identifier>();
				val otherIdentifiers = new ArrayList<Identifier>();
				
				thisIdentifiers.add(interfaceDeclaration.identifiers.head);
				thisIdentifiers.addAll(interfaceDeclaration.identifiers.tail);
				
				for(InterfaceDeclaration otherInterfaceDeclaration : interfaceDeclarations) {
					if(otherInterfaceDeclaration.eContainer().eContainer().eContainer() instanceof EntityDeclaration) {
						otherIdentifiers.add(otherInterfaceDeclaration.identifiers.head);
						otherIdentifiers.addAll(otherInterfaceDeclaration.identifiers.tail);
					}
				}
		
				for(SignalDeclaration otherSignalDeclaration : signalDeclarations) {
					otherIdentifiers.add(otherSignalDeclaration.identifiers.head);
					otherIdentifiers.addAll(otherSignalDeclaration.identifiers.tail);
				}
				
				otherIdentifiers.removeAll(thisIdentifiers);
				
				for(Identifier thisIdentifier : thisIdentifiers) {
					for(Identifier otherIdentifier : otherIdentifiers) {
						if(thisIdentifier.name.equals(otherIdentifier.name)) {
							error('Signal ' + thisIdentifier.name + ' is declared multiple times', thisIdentifier, null);
							error('Signal ' + otherIdentifier.name + ' is declared multiple times', otherIdentifier, null);
						}
					}
				}
			];
		}
	}

	@Check
	def checkForMultipleSignalDeclaration(SignalDeclaration signalDeclaration) {
		val architecture = signalDeclaration.eContainer() as ArchitectureDeclaration;
		val entity = architecture.entityRef;

		if(entity === null) return;

		val interfaceDeclarations = EcoreUtil2.getAllContentsOfType(entity, typeof(InterfaceDeclaration));
		val signalDeclarations = EcoreUtil2.getAllContentsOfType(architecture, typeof(SignalDeclaration));

		val thisIdentifiers = new ArrayList<Identifier>();
		val otherIdentifiers = new ArrayList<Identifier>();
		
		thisIdentifiers.add(signalDeclaration.identifiers.head);
		thisIdentifiers.addAll(signalDeclaration.identifiers.tail);
		
		for(InterfaceDeclaration interfaceDeclaration : interfaceDeclarations) {
			if(interfaceDeclaration.eContainer().eContainer().eContainer() instanceof EntityDeclaration) {
				otherIdentifiers.add(interfaceDeclaration.identifiers.head);
				otherIdentifiers.addAll(interfaceDeclaration.identifiers.tail);
			}
		}

		for(SignalDeclaration otherSignalDeclaration : signalDeclarations) {
			otherIdentifiers.add(otherSignalDeclaration.identifiers.head);
			otherIdentifiers.addAll(otherSignalDeclaration.identifiers.tail);
		}
		
		otherIdentifiers.removeAll(thisIdentifiers);
		
		for(Identifier thisIdentifier : thisIdentifiers) {
			for(Identifier otherIdentifier : otherIdentifiers) {
				if(thisIdentifier.name.equals(otherIdentifier.name)) {
					error('Signal ' + thisIdentifier.name + ' is declared multiple times', thisIdentifier, null);
					error('Signal ' + otherIdentifier.name + ' is declared multiple times', otherIdentifier, null);
				}
			}
		}
	}

	/**
	 * TODO + Do not consider generics
	 */
	@Check
	def checkSignalUsage(InterfaceDeclaration interfaceDeclaration) {
		// Signal of a component declaration should not be checked.
		if (interfaceDeclaration.eContainer().eContainer().eContainer() instanceof ComponentDeclaration ||
			interfaceDeclaration.eContainer().eContainer() instanceof GenericClause) {
			return;
		}

		val model = interfaceDeclaration.eResource().getContents().get(0) as Model;
		val identifierRefs = EcoreUtil2.getAllContentsOfType(model, typeof(IdentifierReference));
		val identifierHead = interfaceDeclaration.identifiers.head;
		val identifierTail = interfaceDeclaration.identifiers.tail;

		// Check head
		var usageCount = getUsageCount(identifierRefs, identifierHead.name);
		if (usageCount == 0) {
			warning('Signal ' + identifierHead.name + ' is never used', identifierHead, null);
		}

		// Check tail
		for (Identifier identifier : identifierTail) {
			usageCount = getUsageCount(identifierRefs, identifier.name);

			if (usageCount == 0) {
				warning('Signal ' + identifier.name + ' is never used', identifier, null);
			}
		}
	}

	@Check
	def checkSignalUsage(SignalDeclaration signalDeclaration) {
		val model = signalDeclaration.eResource().getContents().get(0) as Model;
		val identifierRefs = EcoreUtil2.getAllContentsOfType(model, typeof(IdentifierReference));
		val identifierHead = signalDeclaration.identifiers.head;
		val identifierTail = signalDeclaration.identifiers.tail;

		// Check head
		var usageCount = getUsageCount(identifierRefs, identifierHead.name);
		if (usageCount == 0) {
			warning('Signal ' + identifierHead.name + ' is never used', identifierHead, null);
		}

		// Check tail
		for (Identifier identifier : identifierTail) {
			usageCount = getUsageCount(identifierRefs, identifier.name);

			if (usageCount == 0) {
				warning('Signal ' + identifier.name + ' is never used', identifier, null);
			}
		}
	}

	@Check
	def checkUsageOfComponent(ComponentDeclaration componentDeclaration) {
		val architectureDeclaration = componentDeclaration.eContainer() as ArchitectureDeclaration;
		val componentInstances = EcoreUtil2.getAllContentsOfType(architectureDeclaration,
			typeof(ComponentInstantiationStatement));

		var isInstantiated = false;
		for (ComponentInstantiationStatement componentInstance : componentInstances) {
			if (componentInstance.type.ref.name.equalsIgnoreCase(componentDeclaration.name)) {
				isInstantiated = true;
			}
		}

		if (!isInstantiated) {
			warning('Component ' + componentDeclaration.name + ' is not instantiated', componentDeclaration, null);
		}
	}

	def getUsageCount(List<IdentifierReference> identifierRefs, String signalName) {
		var usageCount = 0;
		for (IdentifierReference identifierRef : identifierRefs) {
			switch identifierRef {
				QualifiedIdentifierReference: {
					if (identifierRef.object.ref.name.equalsIgnoreCase(signalName)) {
						usageCount++;
					}
				}
				default: {
					if (identifierRef.ref !== null && identifierRef.ref.name.equalsIgnoreCase(signalName)) {
						usageCount++;
					}
				}
			}

		}
		return usageCount;
	}

	/**
	 * It is not allowed to have several concurrent statements assigning to the same signal.
	 */
	@Check
	def checkDuplicateAssignmentsOfConcurrentStatements(ArchitectureDeclaration architectureDeclaration) {
		val concurrentStatements = EcoreUtil2.getAllContentsOfType(architectureDeclaration,
			typeof(ConditionalSignalAssignmentSatement));

		// (1) Check that there are no duplicate assignments of concurrent statements
		val concurrentStatementMap = HashMultimap.create();

		for (ConditionalSignalAssignmentSatement concurrentStatement : concurrentStatements) {
			concurrentStatementMap.put(buildQualifiedName(concurrentStatement.target), concurrentStatement);

			for (entry : concurrentStatementMap.asMap.entrySet) {
				val duplicates = entry.value

				if (duplicates.size > 1) {
					for (d : duplicates) {
						if (d.target.constraint === null) {
							error('Duplicate ' + buildQualifiedName(d.target), d.target, null);
						}
					}
				}
			}
		}
	}

	@Check
	def checkDuplicateAssignmentsBetweenProcessAndConcurrentStatements(ProcessStatement processStatement) {
		val architectureDeclaration = processStatement.eContainer() as ArchitectureDeclaration;
		val concurrentStatements = EcoreUtil2.getAllContentsOfType(architectureDeclaration,
			typeof(ConditionalSignalAssignmentSatement));
		val signalAssignments = EcoreUtil2.getAllContentsOfType(processStatement, typeof(SignalAssignmentStatement));

		for (ConditionalSignalAssignmentSatement concurrentStatement : concurrentStatements) {
			for (SignalAssignmentStatement signalAssignment : signalAssignments) {
				val thisSignalAssignmentFQN = buildQualifiedName(signalAssignment.target);
				val concurrentStatementFQN = buildQualifiedName(concurrentStatement.target);

				if (thisSignalAssignmentFQN.equalsIgnoreCase(concurrentStatementFQN)) {
					error('Duplicate ' + buildQualifiedName(signalAssignment.target), signalAssignment.target, null);
					error('Duplicate ' + buildQualifiedName(concurrentStatement.target), concurrentStatement.target,
						null);
				}
			}
		}
	}

	@Check
	def checkDuplicateAssignmentsBetweenProcesses(ProcessStatement processStatement) {
		val architectureDeclaration = processStatement.eContainer() as ArchitectureDeclaration;
		val signalAssignments = EcoreUtil2.getAllContentsOfType(processStatement, typeof(SignalAssignmentStatement));
		val processStatements = EcoreUtil2.getAllContentsOfType(architectureDeclaration, typeof(ProcessStatement));

		processStatements.remove(processStatement);

		// (3) Check that there are no duplicate assignments between processes
		for (ProcessStatement otherProcessStatement : processStatements) {
			val otherSignalAssignments = EcoreUtil2.getAllContentsOfType(otherProcessStatement,
				typeof(SignalAssignmentStatement));

			for (SignalAssignmentStatement otherSignalAssignment : otherSignalAssignments) {
				for (SignalAssignmentStatement signalAssignment : signalAssignments) {
					val thisSignalAssignmentFQN = buildQualifiedName(signalAssignment.target);
					val otherSignalAssignmentFQN = buildQualifiedName(otherSignalAssignment.target);

					if (thisSignalAssignmentFQN.equalsIgnoreCase(otherSignalAssignmentFQN)) {
						error('Duplicate ' + buildQualifiedName(signalAssignment.target), signalAssignment.target,
							null);
						error('Duplicate ' + buildQualifiedName(otherSignalAssignment.target),
							otherSignalAssignment.target, null);
					}
				}
			}
		}
	}

	def String buildQualifiedName(IdentifierReference identifierRef) {
		var retVal = "";
		switch identifierRef {
			QualifiedIdentifierReference: {
				retVal += buildQualifiedName(identifierRef.object) + ".";
				retVal += identifierRef.field.name;
			}
			default: {
				return identifierRef.ref.name
			}
		}
		return retVal;
	}

	/**
	 * Checks for signals that are consumed but never have got assigned a value to.
	 */
	@Check
	def checkUndefinedSignal(SignalDeclaration signalDeclaration) {
		// Gather only identifier references on the left side of an signal assignment
		var identifierRefs = getAssignedSignals(signalDeclaration);
		val identifierHead = signalDeclaration.identifiers.head;
		val identifierTail = signalDeclaration.identifiers.tail;

		// Check head
		var usageCount = getUsageCount(identifierRefs, identifierHead.name);
		if (usageCount == 0) {
			warning('Signal ' + identifierHead.name + ' is never assigned a value to', identifierHead, null);
		}

		// Check tail
		for (Identifier identifier : identifierTail) {
			usageCount = getUsageCount(identifierRefs, identifier.name);

			if (usageCount == 0) {
				warning('Signal ' + identifier.name + ' is never assigned a value to', identifier, null);
			}
		}
	}

	// Gather only identifier references on the left side of an signal assignment
	def getAssignedSignals(EObject eObject) {
		val model = eObject.eResource().getContents().get(0) as Model;
		val signalAssignmentStatements = EcoreUtil2.getAllContentsOfType(model, SignalAssignmentStatement);
		val conditionalSignalAssignmentSatements = EcoreUtil2.getAllContentsOfType(model,
			ConditionalSignalAssignmentSatement);
		var componentInstantiationStatements = EcoreUtil2.getAllContentsOfType(model, ComponentInstantiationStatement);

		var identifierRefs = new ArrayList<IdentifierReference>();
		for (SignalAssignmentStatement signalAssignmentStatement : signalAssignmentStatements) {
			identifierRefs.add(signalAssignmentStatement.target);
		}

		for (ConditionalSignalAssignmentSatement conditionalSignalAssignmentSatement : conditionalSignalAssignmentSatements) {
			identifierRefs.add(conditionalSignalAssignmentSatement.target);
		}

		for (ComponentInstantiationStatement componentInstantiationStatement : componentInstantiationStatements) {
			val associationList = componentInstantiationStatement.portMapAspect.associationList;
			identifierRefs.addAll(EcoreUtil2.getAllContentsOfType(associationList, IdentifierReference));
		}
		return identifierRefs; 
	}

	/**
	 * Checks for signals that are consumed but never have got assigned a value to.
	 */
	@Check
	def checkUndefinedSignal(InterfaceDeclaration interfaceDeclaration) {
		// Signal of a component declaration should not be checked.
		if (interfaceDeclaration.eContainer().eContainer().eContainer() instanceof ComponentDeclaration ||
			interfaceDeclaration.eContainer().eContainer() instanceof GenericClause) {
			return;
		}

		if (interfaceDeclaration.mode.name.equalsIgnoreCase("in"))
			return;

		val model = interfaceDeclaration.eResource().getContents().get(0) as Model;
		val signalAssignmentStatements = EcoreUtil2.getAllContentsOfType(model, SignalAssignmentStatement);
		val conditionalSignalAssignmentSatements = EcoreUtil2.getAllContentsOfType(model,
			ConditionalSignalAssignmentSatement);
		var componentInstantiationStatements = EcoreUtil2.getAllContentsOfType(model, ComponentInstantiationStatement);

		// Gather only identifier references on the left side of an signal assignment
		var identifierRefs = new ArrayList<IdentifierReference>();
		for (SignalAssignmentStatement signalAssignmentStatement : signalAssignmentStatements) {
			identifierRefs.add(signalAssignmentStatement.target);
		}

		for (ConditionalSignalAssignmentSatement conditionalSignalAssignmentSatement : conditionalSignalAssignmentSatements) {
			identifierRefs.add(conditionalSignalAssignmentSatement.target);
		}

		for (ComponentInstantiationStatement componentInstantiationStatement : componentInstantiationStatements) {
			val associationList = componentInstantiationStatement.portMapAspect.associationList;
			identifierRefs.addAll(EcoreUtil2.getAllContentsOfType(associationList, IdentifierReference));
		}

		// Port map of instantiation template
		val identifierHead = interfaceDeclaration.identifiers.head;
		val identifierTail = interfaceDeclaration.identifiers.tail;

		// Check head
		var usageCount = getUsageCount(identifierRefs, identifierHead.name);
		if (usageCount == 0) {
			warning('Signal ' + identifierHead.name + ' is never assigned a value to', identifierHead, null);
		}

		// Check tail
		for (Identifier identifier : identifierTail) {
			usageCount = getUsageCount(identifierRefs, identifier.name);

			if (usageCount == 0) {
				warning('Signal ' + identifier.name + ' is never assigned a value to', identifier, null);
			}
		}
	}

	@Check
	def checkPortSignalMode(InterfaceDeclaration interfaceDeclaration) {
		var portClause = EcoreUtil2.getContainerOfType(interfaceDeclaration, typeof(PortClause));
		if(portClause === null) {
			return;
		}
		
		if(interfaceDeclaration.mode === null) {
			warning('No signal mode specified.', interfaceDeclaration, null);
		}
	}

	@Check
	def checkInvalidSignalAssignment(SignalAssignmentStatement signalAssignmentStatement) {
		var architectureDeclaration = EcoreUtil2.getContainerOfType(signalAssignmentStatement, typeof(ArchitectureDeclaration));
		if(architectureDeclaration === null) {
			return;
		}
		
		var entityDeclaration = architectureDeclaration.getEntityRef()
		var interfaceDeclarations = EcoreUtil2.getAllContentsOfType(entityDeclaration, typeof(InterfaceDeclaration));

		interfaceDeclarations.forEach [interfaceDeclaration |
			if (interfaceDeclaration.mode.name.equalsIgnoreCase("out") ||
				interfaceDeclaration.mode.name.equalsIgnoreCase("inout")) {
				return;
			}
			
			val headIdentifier = signalAssignmentStatement.target.ref;
			if (headIdentifier.name.equals(interfaceDeclaration.identifiers.head.name)) {
				error('Invalid signal assignment ' + headIdentifier.name + ' is declared as input.',	signalAssignmentStatement.target, null);
				return;
			}
			for (Identifier tailIdentifier : interfaceDeclaration.identifiers.tail) {
				if (tailIdentifier.name.equals(interfaceDeclaration.identifiers.head.name)) {
					error('Invalid signal assignment ' + tailIdentifier.name + ' is declared as input.',	signalAssignmentStatement.target, null);
					return;
				}
			}
		]
	}
	
	@Check
	def checkInvalidSignalAssignment(ConditionalSignalAssignmentSatement conditionalSignalAssignmentSatement) {
		var architectureDeclaration = EcoreUtil2.getContainerOfType(conditionalSignalAssignmentSatement, typeof(ArchitectureDeclaration));
		if(architectureDeclaration === null) {
			return;
		}
		
		var entityDeclaration = architectureDeclaration.getEntityRef()
		var interfaceDeclarations = EcoreUtil2.getAllContentsOfType(entityDeclaration, typeof(InterfaceDeclaration));

		interfaceDeclarations.forEach [interfaceDeclaration |
			if (interfaceDeclaration.mode.name.equalsIgnoreCase("out") ||
				interfaceDeclaration.mode.name.equalsIgnoreCase("inout")) {
				return;
			}
			
			val headIdentifier = conditionalSignalAssignmentSatement.target.ref;
			if (headIdentifier.name.equals(interfaceDeclaration.identifiers.head.name)) {
				error('Invalid signal assignment ' + headIdentifier.name + ' is declared as input.',	conditionalSignalAssignmentSatement.target, null);
				return;
			}
			for (Identifier tailIdentifier : interfaceDeclaration.identifiers.tail) {
				if (tailIdentifier.name.equals(interfaceDeclaration.identifiers.head.name)) {
					error('Invalid signal assignment ' + tailIdentifier.name + ' is declared as input.',	conditionalSignalAssignmentSatement.target, null);
					return;
				}
			}
		]
	}
}
